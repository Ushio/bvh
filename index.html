<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <link rel="stylesheet" href="https://gitcdn.xyz/repo/goessner/mdmath/master/css/texmath.css">
    <link rel="stylesheet" href="https://gitcdn.xyz/repo/goessner/mdmath/master/css/vscode-texmath.css">
</head>
<body class="markdown-body">
    <h1 id="bvhe381aee381afe381aae38197-3" data-line="0" class="code-line code-line code-line" id="bvhe381aee381afe381aae38197-4" id="bvhe381aee381afe381aae38197-5">BVHのはなし</h1>
    <p data-line="2" class="code-line code-line code-line">Shinji Ogaki</p>
    <h2 id="e381afe38198e38281e381ab-3" data-line="6" class="code-line code-line code-line" id="e381afe38198e38281e381ab-4" id="e381afe38198e38281e381ab-5">はじめに</h2>
    <p data-line="8" class="code-line code-line code-line">NVIDIAが発表したGPUのように今後レイ・トレーシングは専用のハードウェアで行われていくようになるのかもしれませんが、レイ・トレーシングに使われる基礎的なデータ構造を理解する人・研究をする人が減ってしまうのは残念なので、今日現在でのランドマーク的な手法をまとめてみることにしました。大まかなトレンドをつかんでいただければ幸いです。文献の数に圧倒されるかもしれませんが、Light Transportほど込み入った数学がまったく必要ないので実は勉強は始めやすいのではないかと思います。</p>
    <h2 id="bvhe381a8e381af-3" data-line="10" class="code-line code-line code-line" id="bvhe381a8e381af-4" id="bvhe381a8e381af-5">BVHとは?</h2>
    <p data-line="12" class="code-line code-line code-line">Bounding Volume Hierarchyの略で、レイ・トレーシングの交差判定や物理シミュレーションの衝突判定の高速化で利用される階層的なデータ構造です。交差判定や当たり判定をするときにシーン内のオブジェクトを一つ一つチェックしていくわけには行けませんから、階層的な構造でオブジェクトを扱い、当たらないものをまとめて棄却する、といった使い方をします。もちろんフォトンなどを保持するのにも使ってもいいですし、後ほど取り上げますが、最近ではメッシュ・ライトによる照明計算などにも使用されます。</p>
    <h2 id="e382b3e382b9e38388e996a2e695b0-3" data-line="14" class="code-line code-line code-line" id="e382b3e382b9e38388e996a2e695b0-4" id="e382b3e382b9e38388e996a2e695b0-5">コスト関数</h2>
    <p data-line="16" class="code-line code-line code-line">品質のよいBVHを構築するのはなにかしら品質をはかる尺度が必要になりますが、まずはそこからはじめましょう。</p>
    <h3 id="surface-area-heuristic-sah-3" data-line="18" class="code-line code-line code-line" id="surface-area-heuristic-sah-4" id="surface-area-heuristic-sah-5">Surface Area Heuristic (SAH)</h3>
    <ul>
        <li data-line="20" class="code-line code-line code-line"><a href="https://authors.library.caltech.edu/79167/">Automatic creation of object hierarchies for ray tracing</a></li>
        <li data-line="21" class="code-line code-line code-line"><a href="http://graphicsinterface.org/wp-content/uploads/gi1989-22.pdf">Heuristics for ray tracing using space subdivision</a></li>
    </ul>
    <p data-line="23" class="code-line code-line code-line">この記事にたどり着いた人の多くはSAHという用語を聞いたことがあるかと思います。Surface Area Heuristicの略で、レイトレーシング用の品質の良いBVHを構築する際の基準として広く用いられています。</p>
    <p data-line="25" class="code-line code-line code-line">SAHはレイの分布がシーン内で完全にランダムであると仮定したときの交差判定にかかる平均的なコストを表したもので、これが小さいほど品質のよいBVHであるといえます。</p>
    <p data-line="27" class="code-line code-line code-line">具体的にどう定義されるかを見てみましょう</p>
    <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi></mrow></msub><mo>(</mo><mi>X</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>⋅</mo><msub><mi>C</mi><mi>I</mi></msub><mspace linebreak="newline"></mspace><msub><mi>C</mi><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>X</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><msub><mi>C</mi><mi>T</mi></msub><mo>+</mo><mi>P</mi><mo>(</mo><msub><mi>X</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo>)</mo><mo>⋅</mo><msub><mi>C</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi></mrow></msub><mo>(</mo><msub><mi>X</mi><mn>0</mn></msub><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><msub><mi>X</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo>)</mo><mo>⋅</mo><msub><mi>C</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi></mrow></msub><mo>(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex"> C_{leaf}(X)=|X| \cdot C_I \\ C_{split}(X, X_0, X_1)=C_T + P(X_0 | X) \cdot C_{leaf}(X_0) + P(X_1 | X) \cdot C_{leaf}(X_1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section><ul>
        <li data-line="31" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">C_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>はプリミティブとの交差判定のコスト</li>
        <li data-line="32" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span></span></span></span></eq>はリーフノード<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></eq>に含まれるプリミティブの数</li>
        <li data-line="33" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{leaf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></eq>はノードに含まれるプリミティブ全てと交差判定を行うコスト</li>
        <li data-line="34" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">C_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>はノードをたどるコスト(次のノードに訪れる際のメモリ・アクセスなど)</li>
        <li data-line="35" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{split}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></eq>はインナー・ノード(リーフ以外のノード)のコスト</li>
        <li data-line="36" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(Y|X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></eq>は条件付確率で、ノード<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></eq>のバウンディング・ボックスにレイが当たり、さらに子ノード<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></eq>のバウンディング・ボックスにも当たる確率</li>
    </ul>
    <p data-line="38" class="code-line code-line code-line">さて、レイの分布はシーン内で完全にランダムであると仮定したので、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></eq>の表面積<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">A(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></eq>とすると、条件付確率が<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi>A</mi><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><mrow><mi>A</mi><mo>(</mo><mi>X</mi><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(Y|X)=\frac{A(Y)}{A(X)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>と面積比のみで決められます。そうすると先の再帰的に定義されたコストは次のように展開できます。</p>
    <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub><mo>)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>A</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub><mo>)</mo></mrow></mfrac><mrow><mo fence="true">(</mo><msub><mi>C</mi><mi>T</mi></msub><munder><mo>∑</mo><msub><mi>N</mi><mi>S</mi></msub></munder><mrow><mi>A</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>)</mo></mrow><mo>+</mo><msub><mi>C</mi><mi>I</mi></msub><munder><mo>∑</mo><msub><mi>N</mi><mi>L</mi></msub></munder><mrow><mi>A</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi></mrow></msub><mo>)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">C(X_{root})=\frac{1}{A(X_{root})} \left( C_T \sum_{N_S}{A(X_{split})} + C_I \sum_{N_L}{A(X_{leaf})} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.144641em;vertical-align:-1.394641em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.394641em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.394641em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span></span></eqn></section><ul>
        <li data-line="42" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_{root}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>はルートノード</li>
        <li data-line="43" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">N_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>はBVH内に含まれるインナー・ノードの数</li>
        <li data-line="44" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">N_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>はBVH内に含まれるリーフ・ノードの数</li>
    </ul>
    <p data-line="46" class="code-line code-line code-line">ここで、リーフにはたった一つのプリミティブが含まれることにします。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>と<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>を定数とすると、先の式は<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub><mo>)</mo><mo>=</mo><msub><mi>K</mi><mn>1</mn></msub><msub><mo>∑</mo><msub><mi>N</mi><mi>S</mi></msub></msub><mrow><mi>A</mi><mo>(</mo><msub><mi>X</mi><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>)</mo></mrow><mo>+</mo><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C(X_{root}) = K_1 \sum_{N_S}{A(X_{split})} + K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.150015em;vertical-align:-0.400015em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.4002900000000005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.400015em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>と書き換えることが出来ます。2つの定数はどのようにBVHを構築したとしても変えることが出来ません。すなわち、SAHを最小化することは、全てのインナー・ノードのバウンディング・ボックスの表面積の和を最小化することと等価になります。</p>
    <p data-line="48" class="code-line code-line code-line">分かりにくいと思われた方は、使われている全てのバウンディング・ボックスの表面積の和が小さければ小さいほど良いと覚えておけばよいでしょう。BVHの品質が良い・悪いというのは、SAHが小さい・大きいを意味しています。</p>
    <h3 id="end-point-overlap-epo-3" data-line="50" class="code-line code-line code-line" id="end-point-overlap-epo-4" id="end-point-overlap-epo-5">End Point Overlap (EPO)</h3>
    <p data-line="52" class="code-line code-line code-line">SAHは最もよく使われますが、実際のレイ・トレーシングのパフォーマンスはSAHによって完全に表すことが出来ません。理由はいろいろですが、一つの理由としてノードどうしの重なりが挙げられます。</p>
    <p data-line="54" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/quality-metrics-bounding-volume-hierarchies">On Quality Metrics of Bounding Volume Hierarchies</a></p>
    <p data-line="56" class="code-line code-line code-line">レイの始点あるいは終点が複数のノード内にあった場合には、それらすべてを訪れなければなりません。レイと交差する一番近いプリミティブは大抵、最も近いノード内に含まれますが、そうでない場合もあるので確認作業が必要となります。</p>
    <p data-line="58" class="code-line code-line code-line">このノードのオーバーラップによる追加分のコストをEPOで表します。</p>
    <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>P</mi><mi>O</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>n</mi><mo>∈</mo><mi>N</mi></mrow></munder><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo>)</mo><mfrac><mrow><mi>A</mi><mo>(</mo><mo>(</mo><mi>S</mi><mo>∖</mo><mi>Q</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>∩</mo><mi>n</mi><mo>)</mo></mrow><mrow><mi>A</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">EPO= \sum_{n \in N}{C(n) \frac{A((S \setminus Q(n)) \cap n)}{A(S)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.7487060000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></eqn></section><ul>
        <li data-line="62" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></eq>はシーン中の全ジオメトリ</li>
        <li data-line="63" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Q(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></eq>はノード<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></eq>のサブツリーに属するジオメトリ</li>
        <li data-line="64" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mo>∖</mo><mi>Q</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>∩</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(S \setminus Q(n)) \cap n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></eq>は<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></eq>のサブツリーには属さないが、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></eq>のバウンディング・ボックス内にあるジオメトリ</li>
    </ul>
    <p data-line="66" class="code-line code-line code-line">EPOを加味したコストはSAHとの線形和<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo>)</mo><mi>S</mi><mi>A</mi><mi>H</mi><mo>+</mo><mi>α</mi><mi>E</mi><mi>P</mi><mi>O</mi><mo separator="true">;</mo><mtext> </mtext><mn>0</mn><mo>≤</mo><mi>α</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(1-\alpha) SAH + \alpha EPO;\ 0 \leq \alpha \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></eq>となりますが、残念ながら<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span></eq>はシーンに大きく依存します。また構築や最適化においてこれらのEPOを正確に見積もるのはコスト的に現実的ではないため、依然としてSAHが使われます。</p>
    <h3 id="temporal-sah-t-sah-3" data-line="68" class="code-line code-line code-line" id="temporal-sah-t-sah-4" id="temporal-sah-t-sah-5">Temporal SAH (T-SAH)</h3>
    <p data-line="70" class="code-line code-line code-line"><a href="http://dcgi.fel.cvut.cz/home/bittner/publications/abvh-eg2015.pdf">T-SAH:AnimationOptimizedBoundingVolumeHierarchies</a></p>
    <p data-line="72" class="code-line code-line code-line">SAHを時間軸に拡張したものです。アニメーションの全フレームを考慮して、コストを計算する力技による方法ですが、このように割り切ったアルゴリズムが結果的に広く使われるようになることもあるので無視できません。</p>
    <h3 id="motion-blur-sah-mbsah-3" data-line="74" class="code-line code-line code-line" id="motion-blur-sah-mbsah-4" id="motion-blur-sah-mbsah-5">Motion Blur SAH (MBSAH)</h3>
    <p data-line="76" class="code-line code-line code-line"><a href="https://embree.github.io/papers/2017-HPG-msmblur.pdf">STBVH: ASpatial-TemporalBVHfor EfficientMulti-SegmentMotionBlur</a></p>
    <p data-line="78" class="code-line code-line code-line">モーションブラー用のSAHです。T-SAHではリフィッティングが必要ですが、こちらは必要ありません。</p>
    <h3 id="surface-area-orientation-heuristic-saoh-3" data-line="80" class="code-line code-line code-line" id="surface-area-orientation-heuristic-saoh-4" id="surface-area-orientation-heuristic-saoh-5">Surface Area Orientation Heuristic (SAOH)</h3>
    <p data-line="82" class="code-line code-line code-line">メニー・ライトは最近ホットな話題です。メッシュ・ライトによる照明計算を高速化するためにもBVHが使用されます。</p>
    <p data-line="84" class="code-line code-line code-line"><a href="https://www.highperformancegraphics.org/wp-content/uploads/2018/Papers-Session1/HPG2018_ImportanceSamplingManyLights.pdf">Importance Sampling of Many Lights With Adaptive Tree Splitting</a> <a href="https://www.highperformancegraphics.org/wp-content/uploads/2018/Papers-Session1/HPG2018_ImportanceSamplingManyLights.pdf">(Slides)</a></p>
    <p data-line="86" class="code-line code-line code-line">この論文ではSAOHと呼ばれる尺度を導入して、照明計算に特化したBVHを構築する方法が述べられています。名前のとおり、面の向きを考慮に入れてオブジェクトをグループに分けます。同じ向きに向いているポリゴンをまとめたほうが照明計算には都合がよさそうというのは直感的に分かりますね。</p>
    <p data-line="88" class="code-line code-line code-line">あるポリゴンが選択される確率(PDF)はBVHをトラバースしながら求めます。またMultiple Importance Samplingでレイが当たったポリゴンのPDFを求める必要があるため、BVHのノードに空きがあれば親のノードへの参照をストアしておくとよいでしょう。Refittingの並列化や最適化にも使えて便利です。</p>
    <p data-line="90" class="code-line code-line code-line">実際はBVHの深さと同じ長さのビット配列がリーフにストアされていれば親ノードへの参照は必要はありませんからメモリは節約できます。興味がある人は考えてみてください。</p>
    <h2 id="e6a78be7af89e696b9e6b395-3" data-line="92" class="code-line code-line code-line" id="e6a78be7af89e696b9e6b395-4" id="e6a78be7af89e696b9e6b395-5">構築方法</h2>
    <p data-line="94" class="code-line code-line code-line">構築方法はおおまかにトップダウン型とボトムアップ型に分かれます。</p>
    <h3 id="e38388e38383e38397e38380e382a6e383b3e59e8b-divisive-3" data-line="96" class="code-line code-line code-line" id="e38388e38383e38397e38380e382a6e383b3e59e8b-divisive-4" id="e38388e38383e38397e38380e382a6e383b3e59e8b-divisive-5">トップダウン型 (Divisive)</h3>
    <p data-line="98" class="code-line code-line code-line">現在の主流のトップダウン型では、与えられたプリミティブ全てをまず２つのグループに分け、それぞれのグループをさらに２つに分ける、といった手順で構築します。個の分割はグループに含まれるプリミティブの数が決められた数以下になるまで再帰的に行われます。</p>
    <p data-line="100" class="code-line code-line code-line">オブジェクトをグループに分ける方法は主に２とおりあります。一つはObject Splittingと呼ばれるもので、もう一つはSpatial Splittingと呼ばれるものです。双方にメリットとデメリットがあります。</p>
    <h4 id="e382aae38396e382b8e382a7e382afe38388e58886e589b2-object-splitting-3" data-line="102" class="code-line code-line code-line" id="e382aae38396e382b8e382a7e382afe38388e58886e589b2-object-splitting-4" id="e382aae38396e382b8e382a7e382afe38388e58886e589b2-object-splitting-5">オブジェクト分割 (Object Splitting)</h4>
    <p data-line="104" class="code-line code-line code-line">こちらは重複を許さずにオブジェクトをグループに分ける方法です。プリミティブは必ず右か左の子ノードどちらかに属します。また、重複を許さないためBVHで使用されるノードの数が事前に予測できメモリの管理が簡単です。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></eq>個のリーフがあった場合、ノードは最大でも<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></eq>個となります。また、モーション・ブラーの実装が簡単になるというメリットがあります。</p>
    <p data-line="106" class="code-line code-line code-line">グループに分ける際はSAHが最も小さくなるような分け方をしますが、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></eq>個のプリミティブを２つのグループに分ける組み合わせをすべて試すのは現実的ではありません。一般的には次にあげる２つの方法が使われます。</p>
    <ul>
        <li data-line="108" class="code-line code-line code-line">
            <p data-line="108" class="code-line code-line code-line">
                <a href="">Sweep</a>
                全てのプリミティブの中心座標を分割したい軸方向にソートし、全てを走査して、コストが最小となる分割位置を探します。
            </p>
        </li>
        <li data-line="111" class="code-line code-line code-line">
            <p data-line="111" class="code-line code-line code-line">
                <a href="">Binning</a>
                近似方法ですがSweepで分割した場合と遜色ないBVHを高速に作ることが出来ます。バウンディングボックスを分割したい軸方向に、例えば8や16といった限られた数に分割し、各領域(これをビンと呼びます)に入るプリミティブを数え、表面積を考慮し、どこで分割するかを決めます。プリミティブがどのビンに入るか判定する際にはプリミティブのバウンディング・ボックスの中心座標を使います。
            </p>
        </li>
    </ul>
    <h4 id="e7a9bae99693e58886e589b2-spatial-splitting-3" data-line="114" class="code-line code-line code-line" id="e7a9bae99693e58886e589b2-spatial-splitting-4" id="e7a9bae99693e58886e589b2-spatial-splitting-5">空間分割 (Spatial Splitting)</h4>
    <p data-line="116" class="code-line code-line code-line">こちらは重複を許してグループ分けするもので、大きなポリゴンなどを分割して(切断すると考えてよいでしょう)タイトなバウンディング・ボックスを作ることができるため、交差判定は非常に高速になります。切断されたプリミティブは、２つの子ノード両方に含まれることになるのでBVHのノード数は事前に予測することはできません。kd-treeも同様に空間を切断するので、レイ・トレーシングの速度は変わらないのではと思うかもしれませんが、SplitありのBVHのは、何もない空間を一気にスキップすることができるという点で優位です。</p>
    <p data-line="118" class="code-line code-line code-line">半面、モーション・ブラーの取り扱い、構築はともに複雑になります。入力されるオブジェクトが均等に細かく分割されている場合(映画のアセットなどはディスプレイスメント・マップやサブディビジョン・サーフェスによってメッシュが細かく分割されていることが多い)はメリットがほとんどありません。</p>
    <p data-line="120" class="code-line code-line code-line"><a href="https://www.nvidia.com/docs/IO/77714/sbvh.pdf">Spatial Splits in Bounding Volume Hierarchies</a></p>
    <p data-line="122" class="code-line code-line code-line"><a href="http://rapt.technology/data/pssbvh.pdf">Parallel Spatial Splits in Bounding Volume Hierarchies</a></p>
    <p data-line="124" class="code-line code-line code-line">Spatial Splitsを用いたBVHの構築を並列で高速に行う方法です。複数スレッドの管理が鍵です。ルートに近いノードでパーティションを行うときは、複数のスレッドが協力して行います。ある程度細かくパーティションがなされたあとは、一つのスレッドがサブツリーの構築を行います。他にもSIMDを用いた高速化などが記述されています。</p>
    <p data-line="126" class="code-line code-line code-line"><a href="https://jo.dreggn.org/home/2018_manuka.pdf">Manuka: A batch-shading architecture for spectral path tracing in movie production</a> <a href="https://patents.google.com/patent/US20140362074A1/en">(US20140362074A1)</a></p>
    <h3 id="e3839ce38388e383a0e382a2e38383e38397e59e8b-agglomerative-3" data-line="128" class="code-line code-line code-line" id="e3839ce38388e383a0e382a2e38383e38397e59e8b-agglomerative-4" id="e3839ce38388e383a0e382a2e38383e38397e59e8b-agglomerative-5">ボトムアップ型 (Agglomerative)</h3>
    <p data-line="130" class="code-line code-line code-line">トップダウン型と異なり、プリミティブのペアを作り、さらに出来上がったペアのペアを作る、といったアプローチでBVHを構築します。</p>
    <p data-line="132" class="code-line code-line code-line"><a href="https://www.cs.cornell.edu/~kb/publications/IRT08.pdf">Fast Agglomerative Clustering for Rendering</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/agglomerative.png" width=512>
    </div>
    <p data-line="138" class="code-line code-line code-line">初めてAgglomerative型の構築を導入した論文ですが、品質の良いBVHが作れる反面、ペアを見つけるのに別のデータ構造を用いているため、実際の使い勝手の良さは良くありません。ただし手法自体は有益で、後述するツリーレットの最適化手法でも使用されます。</p>
    <p data-line="140" class="code-line code-line code-line"><a href="http://graphics.cs.cmu.edu/projects/aac/">Efficient BVH Construction via Approximate Agglomerative Clustering</a> <a href="http://www.highperformancegraphics.org/wp-content/uploads/Gu-AAC.pdf">(Slides)</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/aac_bad.png" width=512>
    </div>
    <p data-line="146" class="code-line code-line code-line">Agglomerative Clusteringは図のように細かく分割されたモデルの場合、品質の悪いBVHを生成します。これはバウンディング・ボックスの重なりが大きくなるためで、解決するにはEPOといった別の評価関数を取り入れる必要があります。Manukaのように全てのオブジェクトを細かく分割するタイプの実装では、そのままAgglomerative Clusteringを使うのはお勧めしません。</p>
    <p data-line="148" class="code-line code-line code-line"><a href="https://dcgi.felk.cvut.cz/projects/ploc/ploc-tvcg.pdf">Parallel Locally-Ordered Clustering for Bounding Volume Hierarchy Construction</a></p>
    <p data-line="150" class="code-line code-line code-line">構築の並列性が高くないというAACの問題を克服しています。アルゴリズムは非常に簡単で、まず<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></eq>個のプリミティブが与えられたとき、各プリミティブにつき一つのクラスタ、つまり全部で<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></eq>個のクラスタを用意します。次にこれらをモートン・コードでソートします。ソートは最初に一度だけ行われます。</p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/nn_pairs.png" width=512>
    </div>
    <p data-line="156" class="code-line code-line code-line">つづいて、それぞれのクラスタに対して、自身の前後<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">\pm r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></eq>から最も近いクラスタを探します。全てのクラスタについて最も近いクラスタが見つかったら、最近傍ペアを作ります(図の緑のクラスタ)。最近傍ペアというのはクラスタ<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>と<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></eq>があった時に、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>が<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></eq>の最近傍かつ<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></eq>が<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>の最近傍であるようなペアのことをいいます。次に見つかったペアをマージします。ペアが見つからなかった場合(図の赤のクラスタ)はそのクラスタはそのまま残します。この処理を繰り返し、クラスタが一つになるまで繰り返して、BVHの構築が終了します。これらの処理はダブル・バッファを用いて並列で行うことが出来ます。</p>
    <p data-line="158" class="code-line code-line code-line">個人的には実装しないと思っていたので、きちんと読んでいませんでしたが、分かり易く書かれた良い論文です。アルゴリズムが必ず収束する(各反復で必ずペアが見つかる)のを証明している部分がありますが、簡単なグラフ理論を使ってきれいに書かれています。</p>
    <p data-line="160" class="code-line code-line code-line">論文中ではATRBVHより高速にレンダリングできるシーンが多いもののHappy Buddhaではやはり遅くなると報告されています。</p>
<pre data-line="162" class="code-line code-line code-line"><code>PLOCの論文ではイントロダクションでインサーションも一般的な構築方法の一つだと書いてありますが、個人的にはインサーションは最適化手法に分類するのがふさわしいと思うので最適化のReinsertionのところで紹介します。
</code></pre>
    <h3 id="linear-bvh-lbvh-3" data-line="164" class="code-line code-line code-line" id="linear-bvh-lbvh-4" id="linear-bvh-lbvh-5">Linear BVH (LBVH)</h3>
    <p data-line="166" class="code-line code-line code-line">LBVHは少し分類に迷ったので、独立したカテゴリとすることにします。</p>
    <p data-line="168" class="code-line code-line code-line"><a href="http://graphics.snu.ac.kr/class/graphics2011/references/2007_lauterbach.pdf">Fast BVH Construction on GPUs</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/morton.png" width=512>
        <p data-line="173" class="code-line code-line code-line">image from <a href="https://devblogs.nvidia.com/thinking-parallel-part-iii-tree-construction-gpu/">https://devblogs.nvidia.com/thinking-parallel-part-iii-tree-construction-gpu/</a></p>
    </div>
    <p data-line="176" class="code-line code-line code-line">この論文はLBVHを導入した論文として知られていますが、実は内容は２本立てで、前半がモートン・コードといった空間充填曲線を利用する高速な方法の提案、後半がBinningをつかったSAHを最小化する構築方法の並列化についての解説となっています。</p>
    <p data-line="178" class="code-line code-line code-line">前半部分ですが、シーンをグリッドに細かく分割し(明示的に行うのではなく、モートン・コードなどの空間充填曲線により得られるコードにより陰に行われます)、各オブジェクトが所属するグリッドのIDを空間充填曲線によって求めます。その値が近いもの同士がペアとなります。高速ですが、品質はあまりよくありません。特に局所的にポリゴン数の多いオブジェクトがあるケース(いわゆるteapot in stadium)を苦手とします。</p>
    <p data-line="180" class="code-line code-line code-line">構築はトップダウンかつ逐次型で、まずプリミティブをコードでソートし、ルート・ノードを用意します。そして最上位ビットが変わる部分を見つけ、子ノードを２つ生成します。1つは最上位ビットが０であるプリミティブ用、もう１つは最上位ビットが１であるプリミティブ用です。つづいて、それぞれの子ノードに属するプリミティブに対し同様の処理を行うのですが、次は上から２番目のビットの値が変わる場所(なければ３番目のビット)を見つけ、それぞれのノードにさらに子ノードを２つ追加します。子ノードに属すプリミティブが１つになればそれはリーフであり、そのグループについての処理は終了します。</p>
    <p data-line="182" class="code-line code-line code-line">後半のSAHをつかったBVHの構築はいたって普通で、Binningを使ったものとなっています。一般的に構築時、ルート・ノード付近での並列性はなかなか高めることができないことから、ハイブリッドな手法も提案しています。ルートに近い部分のみLBVHで構築し、残りはBinningを使うというものです。並列性を上げることは出来ますが、ルートに近い部分のノードは一般的に表面積が大きいため、出来上がったツリーの品質についてはあまり期待できません。</p>
    <p data-line="184" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/hlbvh-hierarchical-lbvh-construction-real-time-ray-tracing">HLBVH: Hierarchical LBVH Construction for Real-Time Ray Tracing</a></p>
    <p data-line="186" class="code-line code-line code-line">LBVHの構築はメモリを多く消費してしまうといった欠点がありましたが、ツリーレットを利用し、２段階でBVHを構築することで解決しています。</p>
    <p data-line="188" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/simpler-and-faster-hlbvh-work-queues">Simpler and Faster HLBVH with Work Queues</a></p>
    <p data-line="190" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/maximizing-parallelism-construction-bvhs-octrees-and-k-d-trees">Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d Trees</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/maximize.png" width=512>
    </div>
    <p data-line="196" class="code-line code-line code-line">この論文ではLBVHの構築の並列性を最大限にする方法が記述されています。先に挙げた2つの論文では、HLBVHでメモリ消費などLBVHの構築方法の欠点がいくらか解決されたものの、依然として処理はトップダウンかつ逐次的なものでした。この論文ではすべてのノードを並列に扱う方法が提案されており、Octreeなどにも適用できるなど応用範囲が広いです。LBVHに関しては、これさえ理解しておけば問題ないといえる非常に良い論文です。</p>
    <p data-line="198" class="code-line code-line code-line">構築されるBVHは上図のようなノード(ピンク)とリーフ(グリーン)のレイアウトとなります。アルゴリズムは単純で、それぞれのノードについて独立に、「ノードがカバーする範囲(図中の水平なバー、分権によってはPivotsと書いているものもある)」と「Split(つまり分割位置)」を求めます。BVHの構築にはSplit(言い換えれば子ノードへの参照)だけ分かればよいのですが、ノードがカバーする範囲はSplitを見つけるために使われます。</p>
    <p data-line="200" class="code-line code-line code-line">分かり易くするため、まず、ノード３に注目してみましょう。対応するリーフのコードは<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>00101</mn></mrow><annotation encoding="application/x-tex">00101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span></eq>、右隣のノード4に対応するコードは<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10011</mn></mrow><annotation encoding="application/x-tex">10011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span></span></span></span></eq>、左隣のノード2に対応するコードは<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>00100</mn></mrow><annotation encoding="application/x-tex">00100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></eq>となっています。</p>
    <p data-line="202" class="code-line code-line code-line">ここで<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></eq>を「ノード<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></eq>と<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></eq>のコードの共通な上位ビットの数」としましょう。赤い手書き文字で書かれた数字です。最上位ビットが異なるので、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta(3,4)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></eq>です。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\delta(3,2)=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></eq>となります。</p>
    <p data-line="204" class="code-line code-line code-line"><eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo>−</mo><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo><mo>=</mo><mo>−</mo><mn>4</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta(3,4)-\delta(3,2)=-4&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></eq>となります。この値がマイナスであった場合は、リーフ3はこのノードの先頭(左端)ではなく、末尾(右端)であることが分かります。逆に、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>δ</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>−</mo><mi>δ</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">0 \leq \delta(i,i+1)-\delta(i,i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>の時はこのノードがカバーする範囲の先頭となります。ノード5を見ればこの値は<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">4-1=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></eq>となっています。</p>
    <p data-line="206" class="code-line code-line code-line">同様にコードを調べ、逆の端点、つまり対象ノードが末尾であった場合は先頭を、先頭であった場合は末尾を探します。ノード3は末尾であるので、左方向に探索を行います。探し方は特殊で、まず進む方向と逆の右隣を見て、<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(3,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span></eq>を求めます。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></eq>ですね。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">0&lt;\delta(3,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></eq>である間、左へ進んでいき、結果<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></eq>となります。ノード5の場合は先頭であるので、右へ進んでいきます。同様にまず逆の左隣をみて<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(5,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span></eq>を求めます。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></eq>ですね。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>δ</mi><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">1&lt;\delta(5,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></eq>である間、右へ進みます。結果<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">j=7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span></eq>となります</p>
    <p data-line="208" class="code-line code-line code-line">つづいてSplitを探します。ノード3の場合は<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\delta(3,0)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></eq>なので<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span></eq>が<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></eq>からそれより大きな値へ変化するところつまり2と1の間がSplitとなります。ノード5の場合は<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo>)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\delta(5,7)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></eq>で、同様に<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></eq>から大きな値に変化する場所つまり6と7の間がSplitとなります。探索には二分探索などが使えます。</p>
    <p data-line="210" class="code-line code-line code-line">以上のように、各ノードが完全に独立して子ノードへの参照を求めることができるという素晴らしい手法です。</p>
    <p data-line="212" class="code-line code-line code-line"><a href="https://devblogs.nvidia.com/thinking-parallel-part-iii-tree-construction-gpu/">Thinking Parallel, Part III</a></p>
    <p data-line="214" class="code-line code-line code-line">著者によるブログでも解説されています。</p>
    <p data-line="216" class="code-line code-line code-line"><a href="http://dcgi.felk.cvut.cz/projects/emc/">Extended Morton Codes for High Performance Bounding Volume Hierarchy Construction</a></p>
    <p data-line="218" class="code-line code-line code-line">LBVHが苦手とするteapot in stadium問題に対する対策が書かれています。</p>
    <h3 id="e79b86e6a0bd-3" data-line="220" class="code-line code-line code-line" id="e79b86e6a0bd-4" id="e79b86e6a0bd-5">盆栽</h3>
    <p data-line="222" class="code-line code-line code-line">ミニ・ツリーという小さなツリーを大量に並列で構築し、それらをさらにまとめて一つのBVHにまとめる方法もあります。</p>
    <p data-line="224" class="code-line code-line code-line"><a href="http://jcgt.org/published/0004/03/02/paper.pdf">Bonsai: Rapid Bounding Volume Hierarchy Generation using Mini Trees</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/bonsai.png" width=512>
    </div>
    <p data-line="229" class="code-line code-line code-line">ミニ・ツリーをたくさん構築して、それぞれのミニ・ツリーをリーフとみなし、BVHを構築しますが、そのままでは質のいいBVHが作れるとは限りません。ミニ・ツリーのルートのバウンディングボックスが大きい場合は、刈込み(Pruning)を行います。刈込みとは、ルートに近いノードをばらし、ミニ・ツリーをさらにいくつかのミニ・ツリーに分ける操作で、それらから再び一つのBVHを構築します。これが盆栽（Bonsai)と名づけられた所以です。</p>
    <p data-line="231" class="code-line code-line code-line">侮るなかれ。この刈込みは様々なプリミティブに対してBVHを構築し、それらを一つのBVHにまとめる時の有力な手段となりますし、同じような考え方はRe-braidingの論文でも用いられています。</p>
    <h2 id="e58886e589b2e7b5b1e6b2bbe6b395dacrt-3" data-line="233" class="code-line code-line code-line" id="e58886e589b2e7b5b1e6b2bbe6b395dacrt-4" id="e58886e589b2e7b5b1e6b2bbe6b395dacrt-5">分割統治法(DACRT)</h2>
    <p data-line="235" class="code-line code-line code-line">構築方法について述べましたので、構築しない方法についても触れたいと思います。日本語にすると分割統治法(Divide and Conquer Ray Tracing, DACRT)と呼ばれるアプローチで、構築とトラバースを同時に行い、構築したBVHを保存して再利用しないのが特徴で、動的なシーンのレンダリングに適しています。</p>
    <p data-line="237" class="code-line code-line code-line">陰的なデータ構造にはBVHやkd-treeなど任意なものを用いることが出来て、メリットとデメリットをそのまま継承します。</p>
    <p data-line="239" class="code-line code-line code-line">学術的には大変面白い手法ですが、プロダクション・レンダラで採用されないのには理由があります。この方法ではパフォーマンスを上げるため、あるいは構築分のコストを償却するため同時に多くのレイ扱いますが、プロダクション・レンダラでは一つのレイに非常に多くの情報(レイ微分、QMCなどサンプルに関連する情報、反射回数などなど)が付随しています。したがって生存期間が重なるレイが増えると、メモリの消費が膨大になってしまうというジレンマに陥ります。また、並列化されたアルゴリズムも提案されていますが、リニアにスケールさせるのも難しいようです。</p>
    <p data-line="241" class="code-line code-line code-line">DACRTをテーマにした論文にはどれも簡単に見つけられる(あるいは改善できる)欠点があり、突き詰めてやったものがないという印象を受けます。逆に、論文を書くには大変良いテーマなのではないでしょうか。もちろん、プロダクションで使えるレベルに昇華させるのはまた別の問題です。</p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/dacrt.png" width=512>
    </div>
    <p data-line="247" class="code-line code-line code-line">構築はまず、シーンを含むバウンディング・ボックス、プリミティブのリスト、それからレイのリストを入力し、まず、プリミティブを何らかの基準によって2つのグループに分けます。一番単純な方法は、長軸でバウンディング・ボックスを2つに切断し、その2つのうちどちらかに含まれるかによって分類するものです。レイも同様に、左の子ノードにヒットするもの、右の子ノードにヒットするもの、といった具合に分類します。グループに分ける処理は一般的にフィルタリングと呼ばれます。フィルタリングを終えると、２つの子ノード、2つのプリミティブのリスト、2つのレイのリストができるので、それらに対しさらに同様の処理を行い、レイのリストのサイズとプリミティブのリストのサイズがある程度小さくなったら、総当たりの交差判定を行います。</p>
    <p data-line="249" class="code-line code-line code-line">フィルタリングは陰に使用するデータ構造やアルゴリズムにより異なり、右のノードにヒットするもの、左のノードにヒットするもの、それから両方のノードにヒットするものといった具合に3つにグループ分けすることもあります。</p>
    <p data-line="251" class="code-line code-line code-line"><a href="https://hal.inria.fr/hal-00171587/document">Whitted Ray-Tracing for Dynamic Scenes using a Ray-Space Hierarchy on the GPU</a></p>
    <p data-line="253" class="code-line code-line code-line"><a href="https://fenix.tecnico.ulisboa.pt/downloadFile/563345090414314/68604-dissertation.pdf">Coherent Ray-Space Hierarchy via Ray Hashing and Sorting</a></p>
    <p data-line="255" class="code-line code-line code-line"><a href="https://dl.acm.org/citation.cfm?id=2019636">Naive ray-tracing: A divide-and-conquer approach</a></p>
    <p data-line="257" class="code-line code-line code-line"><a href="http://www.wakayama-u.ac.jp/~iwasaki/project/dacrt/hpg2013final.pdf">Efficient Divide-And-Conquer Ray Tracing using Ray Sampling</a></p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/efficient_dacrt.png" width=512>
    </div>
    <p data-line="263" class="code-line code-line code-line">この論文では陰的なデータ構造にBVHを利用しており、プリミティブは、コスト関数にSAHを用いて、Binningを用いて2つのグループに分けられます。ただし、コストの計算では単純に親ノードと子ノードの面積比を用いず、サンプリングによって選ばれた一部のレイ(Representative Rays)を用いて、レイが子ノードにあたる確率を近似しています。こうすることで、実際のシーン中のレイの分布が考慮されるため、交差判定の高速化が期待できます。レイに相関がある場合効果が期待できそうです。</p>
    <p data-line="265" class="code-line code-line code-line">プリミティブをグループ分けした後、レイを「左のノードに当たるもの」と「右のノードに当たるもの」の２つのグループに分けるフィルタリングの処理を行います。フィルタリング後、トラバースを行いますが、サンプルされたレイの過半数が左のノードに当たる場合は左のノードを先に、過半数が右のノードに当たる場合は右のノードを先に、トラバースします。</p>
    <p data-line="267" class="code-line code-line code-line">理にかなったように見えますが、実はここがこの論文の欠点となっています。例えばレイのバッチ・サイズが100本であった場合、51本が右、49本が左のノードが近いといった状況であれば、右のノードを先にトラバース(再帰的にDACRT)するわけですが、本来左のノードを先にトラバースすべきレイは、右のノードを先にたどらざるを得なくなります。したがって、本来テストしなくてよかったプリミティブとの交差判定を行う必要が出てきます。民主主義的にトラバースの順番を決めているので、すべてのレイについて最適ではありません。ただし、これは数行のコードの追加で修正できますので、それほど大きな問題ではありません。また、レイがどちらか一方のノードのみとしか交差しないという状況であれば、この問題は起こりません。</p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/skip_filtering.png" width=512>
    </div>
    <p data-line="273" class="code-line code-line code-line">Representative Raysに基づいた確率の以外に、この論文にはもう一つ、レイのフィルタリングをスキップするというアイデアが導入されています。レイのフィルタリングはアクティブなレイの数を減らすのに役立ちますが、レイの原点や向き、ノードの位置によってはフィルタリングしてもアクティブなレイがほとんど減らないことがあります。そういった場合はフィルタリングをスキップしたほうが効率がよくなります。</p>
    <p data-line="275" class="code-line code-line code-line">また、残念ながらこの方法は並列化が考慮されていません。</p>
    <p data-line="277" class="code-line code-line code-line"><a href="https://www.cs.dartmouth.edu/~sriravic/papers/pdacrt.pdf">Parallel Divide and Conquer Ray Tracing</a></p>
    <p data-line="279" class="code-line code-line code-line">この論文では、DACRTを並列化することにのみ焦点を当てています。ルート・ノードとプリミティブとレイのリストから処理を始めるのは共通ですが、出来上がった子ノードを再帰による深さ優先の処理ではなく、幅優先で並列に処理していきます。</p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/pdacrt_split.png" width=512>
    </div>
    <p data-line="285" class="code-line code-line code-line">それぞれのノードにおいて、バウンディング・ボックスを２つに分割したのち、プリミティブ(ここではTriangle)を3つのグループに分けます。Node0にのみ含まれるもの、Node1にのみ含まれるもの、両方をまたぐもの、の3つです。レイは4つにグループ分けされます。Node0あるいはNode1にのみヒットするもの、両方にヒットするもの、それから、どちらにもヒットしないものです。</p>
    <div align="center">
        <img src="https://github.com/shinjiogaki/bvh/blob/master/figures/pdacrt_sort.png" width=512>
    </div>
    <p data-line="291" class="code-line code-line code-line">次にそれぞれのリストをグループによってソートします。どちらにもヒットしなかったレイは、除去されます。深さを一つ進めるには、レイとプリミティブのリストを作り直します。上の図の例でいうと、Triangle Idsは1,2,6～24までと3,4,5～25までのリストの2つをくっつけたものが新たに生成され、現在のリストは破棄されます。レイのリストも同様に1～9までのリストと2～25までのリストの2つをくっつけたものが新たに生成されますが、レイのリストの場合は、最近傍点を見つけたり、子ノードにヒットしないなどで、一般的にサイズ小さくなっていくのでメモリ消費の問題は深刻ではありません。</p>
<pre data-line="293" class="code-line code-line code-line"><code>陰に利用されるデータ構造にはBVHではなくkd-treeが用いられているので、「BVHのはなし」と題した記事で取り上げるのはどうかとも思いましたが、ここで解説しておきます。
</code></pre>
    <p data-line="295" class="code-line code-line code-line">kd-treeを用いた理由は高速化のためであると思われます。しかし、kd-treeを用いたがために、プリミティブのグループ分けがObject SplittingのBVHとは異なり、イン・プレイスで出来なくなってしまい、深いレベルにいくにつれてプリミティブの参照が重複し増えていきます。論文中でもこれは欠点として触れられており、DACRTは本来省メモリが売りであるにも関わらず、子ノードをまたぐプリミティブの参照によってメモリの消費が膨大になってしまうというジレンマに陥っています。</p>
    <div align="center">
        <img src="figures/terminals.png" width=512>
    </div>
    <p data-line="301" class="code-line code-line code-line">さて、先述の通り、レイのグループとプリミティブのグループが十分に小さくなったら総当たりの交差判定を行うのですが、この処理も並列化されています。閾値サイズ以下になったレイとプリミティブのグループ(あるいは、ターミナル・ノードに所属するといいます)は事前に確保されたバッファへとコピーされます(上図)。バッファがいっぱいになれば、各ノード内においてレイとプリミティブの交差判定を行います。すべてのノードは並列に処理されます。それぞれのレイは最近点までの距離とヒットしたオブジェクトのIDを持ちますが、それらはmin_tバッファ、hit_idバッファとしてグローバルに確保された配列にストアされます。バッファがいっぱいになるまでこの処理は行われないので、最近点までの距離が更新されず、それまでは無駄な交差判定が行われることになります。</p>
    <p data-line="303" class="code-line code-line code-line">また、幅優先で処理する代償として、順序付きトラバーサルをあきらめています。右、あるいは左のノードがレイの原点から近い、といった情報は一切使用せず、基本的にはどちらもチェックするという非常に効率の悪いアルゴリズムが用いられています。</p>
    <p data-line="305" class="code-line code-line code-line">構築の手法の解説で触れたように、ルート・ノード近くは並列性を高めるのが難しく、また非常に効率の悪いトラバースを行うので、GPUを用いたにもかかわらず、大した高速化が出来ていません。並列化しただけという内容の論文ですが、逆に並列化の難しさを伝えてるという役割を果たしているように思います。</p>
    <p data-line="307" class="code-line code-line code-line"><a href="https://ieeexplore.ieee.org/document/6915284">Improving Divide-and-Conquer Ray-Tracing Using a Parallel Approach</a></p>
    <p data-line="309" class="code-line code-line code-line">こちらも並列化をテーマにした論文ですが、Parallel DACRTと比べていくつか工夫がされています。</p>
    <div align="center">
        <img src="transfer.png" width=512>
    </div>
    <p data-line="315" class="code-line code-line code-line">この論文ではレイとプリミティブをスレッド数に応じて複数のグループに分け、各スレッドが１つのレイのグループと１つのプリミティブのグループの交差判定を行います。もちろんこれだけでは各レイが最近傍点を見つけることができませんので、レイのグループは別のプリミティブのグループと交差判定を行う必要があります。もっとも単純なケースでは、上図のようにそれぞれ２つのグループがある場合で、レイのグループを単純にスワップさせればよいことがわかります。</p>
    <div align="center">
        <img src="transfer_multi.png" width=512>
    </div>
    <p data-line="321" class="code-line code-line code-line">スレッド数が増えるにつれ、レイとプリミティブのグループの数は増えていきます。ですのでノードが2つだけであればレイのグループをスワップさせればよかったのですが、複数ある場合は上図のようにレイのグループをまだ交差判定を行っていないプリミティブのグループのほうへ移していきます。この移す順番と開始点はレイの始点と方向に依存します。当然ながら近いプリミティブのグループから処理したほうが効率が良いわけですが、処理開始時点での最適なレイとプリミティブのグループのペアを何かしらのコスト関数を最小化するように決めるのは難しいのではないでしょうか。</p>
    <p data-line="323" class="code-line code-line code-line">面白い方法ですが、パフォーマンスはスレッド数に比例しておらず、改善の余地があることを示唆しています。</p>
    <h2 id="e69c80e981a9e58c96-3" data-line="325" class="code-line code-line code-line" id="e69c80e981a9e58c96-4" id="e69c80e981a9e58c96-5">最適化</h2>
    <p data-line="327" class="code-line code-line code-line">ここから最適化の話に入ります。最適化手法にはBVHのトポロジーを変更するもの、またノードの並びを変更するもの、メモリの節約を行うものなど、様々なものがあります。</p>
    <p data-line="329" class="code-line code-line code-line">BVHの品質を上げる最適化は、SAHのみを考慮するもの、それからRepresentative Raysと呼ばれるレイを投げ、シーン内での実際のレイの分布を考慮に入れるものの2つに分けることが出来ます。後者のタイプではどのレイが、どのノードに当たったか、どのリーフに当たったか、といった記録を取る必要があるので追加のコストが必要になりますが、レンダリングするシーンに最適な結果を導き出すことができます。コンパイラのProfile Guided Optimizationと似たコンセプトです。Representative Raysは実際のレンダリングに使われるレイの一部分（数パーセント）であるため、それによって得られた結果は無駄にはなりません。このような最適化は、静的なシーン用のBVH構築直後、または、動的なシーンでBVHの品質が下がっていくのを防ぐ場合に使用します。</p>
    <h3 id="wide-bvh-n-ary-bvh-3" data-line="331" class="code-line code-line code-line" id="wide-bvh-n-ary-bvh-4" id="wide-bvh-n-ary-bvh-5">Wide BVH (N-ary BVH)</h3>
    <p data-line="333" class="code-line code-line code-line">現在主に使われているIntelやAMDのCPUはSIMDといわれる４から16の演算を並列に実行するユニットが備わっていますので、CPUの実装ではWide BVHが使われることがほとんどです。SSE、AVX、AVX-512といったユニットを聞いたことがあるでしょうか？Wide BVHはそれらを活用するために提案されました。</p>
    <p data-line="335" class="code-line code-line code-line">通常実装にはSOA(Structure of Arrays)を使います。複数のバウンディング・ボックスのデータが隣接するのでメモリのアクセスの点で有利です。</p>
    <p data-line="337" class="code-line code-line code-line">一つのノード自体は大きくなりますが、ノードの数自体が減るので、メモリ消費の観点からは64ビット消費するポインタではなく32ビットのインデックスで管理したほうが良いでしょう。</p>
<pre data-line="339" class="code-line code-line code-line"><code>少し話がそれますが、これに限らずポインタの使用は勧めしません。integerのインデックスでよい場合はインデックスを使うように心がけましょう。インデックスが妥当かどうかは値が-1(あるいは最大値)かどうかでチェックします。ポインタでもnullかどうかで判別できるから同じだと思うかもしれませんが、それは早とちりです。インデックスの利点は配列のサイズが分かっていた場合、値の上限についてもチェックできるという点で、バグが発見しやすくなります。個人的にはメモリ節約よりもこれによる恩恵のほうが大きいと感じています。私が作っているレンダラはインデックスに切り替えてからクラッシュ・バグと戦うことがほぼなくなりました。自分の経験では、製品でもクラッシュするバグはだいたいポインタがらみです。
</code></pre>
    <p data-line="341" class="code-line code-line code-line"><a href="https://dspace.jaist.ac.jp/dspace/bitstream/10119/3530/2/091paper.pdf">並列演算に適したバウンディングボリューム階層によるレイトレーシングの高速化</a></p>
    <p data-line="343" class="code-line code-line code-line">QBVHと呼ばれているものです。おそらくQBVHを解説する英語の文献になったのは次にあげるものが最初ですが、英語で早く書くことの大切さを思い知らされる出来事です。</p>
    <p data-line="345" class="code-line code-line code-line"><a href="https://www.uni-ulm.de/fileadmin/website_uni_ulm/iui.inst.100/institut/Papers/QBVH.pdf">Shallow Bounding Volume Hierarchies for Fast SIMD Ray Tracing of Incoherent Rays</a></p>
    <p data-line="347" class="code-line code-line code-line">QBVHについては日本語のを読んだからこちらは読まなくてもいいと思うかもしれませんが、この論文ではさらにShadow Rayの高速化について触れていますので一読の価値ありです。基本的には、あるノードからトラバースを開始してヒットしなければ親ノードに戻る、ということを行いますが、親へ戻ってトラバースするには、親ノードへの参照が必要になること、またSIMDの幅がNであった場合に、そのうちの一つは既に計算済みですから、使用率が100%ではなく<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N-1}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>になってしまうという欠点があります。</p>
    <p data-line="349" class="code-line code-line code-line">レイの始点と終点がいつも特定のノードに収まる場合には、ルート・ノードからトラバースせず、特定のノード以下(サブツリー)だけ対象にすればいいので、高速化を行うことが可能です。この場合は親ノードへの参照も必要ありませんし、SIMDの使用率も落ちません。また、始点が含まれるルート以外のノードからトラバースを開始して、何もヒットしなかったら改めてルートからルートからたどる、ということも可能です。こういったテクニックの使いどころは、近年はやりのランダム・ウォークをつかったサブサーフェス・スキャッタリングや、探索半径が限定できるラウンド・コーナーや曲率を求めるシェーダーなどが良い例ではないでしょうか。</p>
    <p data-line="351" class="code-line code-line code-line"><a href="https://voxelium.wordpress.com/2013/08/14/faster-incoherent-ray-traversal-using-8-wide-avx-instructions/">Faster Incoherent Ray Traversal Using 8-Wide AVX Instructions</a></p>
    <p data-line="353" class="code-line code-line code-line">こちらはAVXを利用して8-ary BVHにしたもの。幅が広がるほどレイが当たったノードのソートに時間がかかるようになりますが、この論文では当たった数によって、ソートのコード・パスを変えることで高速化できるということが書かれています。</p>
    <p data-line="355" class="code-line code-line code-line"><a href="http://graphics.cs.ucdavis.edu/~hamann/FuetterlingLojewskiPfreundtHamannEbertHPG2017PaperFinal06222017.pdf">Accelerated Single Ray Tracing for Wide Vector Units</a></p>
    <p data-line="357" class="code-line code-line code-line">これはAVX-512を利用してさらに16-ary BVHとしたもの。幅が増えただけと思うかもしれませんが、先も述べたようにWide BVHではレイが交差したノードのソートがボトルネックになります。この論文ではQBVHの論文のようにソートなしで訪れる順序を決める方法が書かれているので目を通しておくとよいでしょう。</p>
    <p data-line="359" class="code-line code-line code-line">この記事の執筆時点ではAVX-512を搭載したCPUはそれほど多く出回っていませんが、使用する場合動作クロックを落とすことがあるようで、どんどんSIMDの幅が広がっていくかといえば、残念ながらそうでもないようです。しかし、ディープ・ラーニングの普及は、幅の広いSIMDの普及に追い風となるのではないでしょうか。</p>
    <p data-line="361" class="code-line code-line code-line"><a href="https://github.com/shinjiogaki/reports/blob/master/report.pdf">Fragmentation-Aware BVH Contraction</a></p>
    <p data-line="363" class="code-line code-line code-line">Wide BVHの構築の際に、子ノードの数がBVHの幅より小さくなることがあります。一般的には子ノードの数が幅と等しくなるようコスト関数を修正して(例えばオブジェクトの数が４や８の倍数のときボーナスを加えるなど)隙間をなくすようにします。それでもスカスカのリーフだけを含むノードによってメモリが無駄に消費されてしまうことがあります。</p>
    <p data-line="365" class="code-line code-line code-line">このレポートでは、空きスペースのあるノードのペアを見つけて、マージするという簡単な解決策を提案しています。例えばOBVHを利用しているときには、3つ空きがあるノードと５つ空きがあるノードをマージすることによって、無駄なスペースを完全に無くすことが出来ます。パフォーマンスの低下はほぼありません。適当に付けたので、ふさわしい名前かどうかは分かりません。</p>
    <h3 id="contractioncollapsing-3" data-line="367" class="code-line code-line code-line" id="contractioncollapsing-4" id="contractioncollapsing-5">Contraction/Collapsing</h3>
    <div align="center">
        <img src="contraction.png" width=512>
    </div>
    <p data-line="373" class="code-line code-line code-line">Contractionとは2分木型のBinary BVHを、N分木型のWide BVHへと変換する処理のことをいいます。Collapseという用語を使う場合もあります。プロダクション・レンダラではこの処理を明示的に行うことはなく、直接Wide BVHを構築します。理由は単純で、Binary BVHとWide BVHの両方を保持するメモリが無駄だからです。ただし、構築の過程でContractionの考え方は必要になります。実は奥が深く、やり方次第で出来上がったWide BVHの品質が大きく左右されます。最近では、先述のようにWide BVHの利用がGPUでも効果的であると認められてきているので、覚えておくとよいでしょう。</p>
    <p data-line="375" class="code-line code-line code-line"><a href="https://paginas.fe.up.pt/~ei06035/paper/adaptive-collapsing-bvh-for-raytracing.pdf">Adaptive Collapsing on Bounding Volume Hierarchies for Ray-Tracing</a></p>
    <p data-line="377" class="code-line code-line code-line">最適なコントラクションを動的計画法によって求めます。実装がやや面倒になってしまうのが難点です。</p>
    <p data-line="379" class="code-line code-line code-line"><a href="https://www.cs.cmu.edu/~ygu1/paper/PG15/conference.pdf">Ray Specialized Contraction on Bounding Volume Hierarchies</a></p>
    <p data-line="381" class="code-line code-line code-line">この方法はBinary BVHをビルドした後、Representative Raysを投げ(実際のレンダリングで使用されるレイの数パーセント程度)、レンダリングを行います。ここではBinary BVHを使用しますが、その際、レイがどのノードをどれだけ訪れたかを記録しておきます。</p>
    <p data-line="383" class="code-line code-line code-line">そのあとコントラクションを行う際には、Representative Rayが多く訪れたノードを優先して展開します。こうすることでSAHではなく実際のシーンにおけるレイの分布に最適化されたWide BVHを作ることができ、それを用いて非常に効率の良いレンダリングができるようになります。個人的には目からうろこの手法で、Sponzaでは20％強の高速化が得られました。</p>
    <h3 id="wide-bvh-on-gpu-3" data-line="385" class="code-line code-line code-line" id="wide-bvh-on-gpu-4" id="wide-bvh-on-gpu-5">Wide BVH on GPU</h3>
    <p data-line="387" class="code-line code-line code-line">最近の研究ではGPUでもWide BVHの使用は効果があることが報告されています。</p>
    <p data-line="389" class="code-line code-line code-line"><a href="https://users.aalto.fi/~laines9/publications/ylitie2017hpg_paper.pdf">Efficient Incoherent Ray Traversal on GPUs Through Compressed Wide BVHs</a></p>
    <p data-line="391" class="code-line code-line code-line">これはWide BVHをGPUで使用したものです。圧縮したノードを利用することでメモリ帯域の圧迫を避け、高速化を達成しています。</p>
    <p data-line="393" class="code-line code-line code-line"><a href="https://github.com/lispbub/simd-ray-traversal">CPU-style SIMD ray traversal on GPUs</a></p>
    <p data-line="395" class="code-line code-line code-line">こちらはCPUと同じようにWideBVHをGPUで使った場合に高速化できることが示されています。</p>
    <h3 id="refitting-3" data-line="397" class="code-line code-line code-line" id="refitting-4" id="refitting-5">Refitting</h3>
    <p data-line="399" class="code-line code-line code-line">動いているものを扱うときに、BVHのノードのバウンディング・ボックスが中にあるオブジェクトをきちんと内包していなければ交差判定の結果がおかしくなったり、またルーズにフィットしていると処理に余計な時間がかかります。バウンディング・ボックスをフィットさせる処理自体は非常に簡単ですが、並列化で完全にリニアにスケールさせるのは思いのほか難しいものです。</p>
    <p data-line="401" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/maximizing-parallelism-construction-bvhs-octrees-and-k-d-trees">Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d Trees</a></p>
    <p data-line="403" class="code-line code-line code-line">atomicmaxが使える環境であれば、各ノードに親ノードへの参照を持たせることで比較的簡単に並列化できます。</p>
    <h3 id="restructuring-3" data-line="405" class="code-line code-line code-line" id="restructuring-4" id="restructuring-5">Restructuring</h3>
    <p data-line="407" class="code-line code-line code-line">BVHからツリーレットを切りだしてきて、ツリーレットの末端ノードを一旦リーフとみなし、それらに対して先ほど紹介したボトムアップ型の構築を適用し、ツリーレットを作り直す操作をRestructuringと呼びます。</p>
    <p data-line="409" class="code-line code-line code-line">すでに紹介したLBVHは非常に高速にBVHを構築することができますが、品質自体はあまりよくありません。ですので、この再構築による最適化と組み合わせて品質を上げるといったことが行われます。</p>
    <p data-line="411" class="code-line code-line code-line"><a href="https://research.nvidia.com/publication/fast-parallel-construction-high-quality-bounding-volume-hierarchies">Fast Parallel Construction of High-Quality Bounding Volume Hierarchies</a> <a href="https://patents.google.com/patent/US20140365532A1/en">(US20140365532A1)</a></p>
    <div align="center">
        <img src="trbvh.png" width=512>
    </div>
    <p data-line="417" class="code-line code-line code-line">ツリーレットの再構築することで品質を改善します。高速なLVBHで構築したBVHなどと組み合わせて使用されます。</p>
    <p data-line="419" class="code-line code-line code-line"><a href="http://repositorio.unicamp.br/bitstream/REPOSIP/275656/1/Domingues_LeonardoRodrigo_M.pdf">GPU Optimization of Bounding Volume Hierarchies for Ray Tracing</a> <a href="https://patents.google.com/patent/US9817919B2/en">(US9817919B2)</a></p>
    <div align="center">
        <img src="distance_matrix.png" width=512>
    </div>
    <p data-line="425" class="code-line code-line code-line">TRBVHでツリーレットの再構築を行う部分にAgglomerative Clusteringを利用したものです。TRBVHよりほんの少し品質が落ちるものの、高速に実行することができます。AACと同様にDistance Matrixを使って最適なノード(ツリーレットにおけるリーフ)の組み合わせを探すという考え方さえ押さえておけばよいでしょう。論文中には、限られたメモリのサイズで効率よくDistance Matrixを更新する方法が書かれています。当然ながら、Agglomerative Clusteringの欠点を引き継ぐので、細かくテッセレーションされたオブジェクトに適用し続けても、交差判定のパフォーマンスは逆に下がってしまうことがあります。</p>
    <h3 id="rotationreinsertion-3" data-line="427" class="code-line code-line code-line" id="rotationreinsertion-4" id="rotationreinsertion-5">Rotation/Reinsertion</h3>
    <div align="center">
        <img src="rotation.gif" height=128>
        <p data-line="432" class="code-line code-line code-line">(image from: <a href="https://en.wikipedia.org/wiki/Tree_rotation">https://en.wikipedia.org/wiki/Tree_rotation</a>)</p>
    </div>
    <p data-line="435" class="code-line code-line code-line">トポロジーを変更するもっとも簡単手法はRotationで、これを一般化したものはReinsertionと呼ばれます。</p>
    <p data-line="437" class="code-line code-line code-line">SAHを下げるようにRotationを行い続けても実際のレイ・トレーシングのパフォーマンスが上がらないことが多いです。これは、先に挙げたEPOからもわかるようにSAH自体がふさわしい尺度でないこと、またこの操作が実際のシーンにおけるレイの分布を考慮していないことなどが原因として考えられます。ツリーがいたずらに深くなるだけといったことも起こります。</p>
    <p data-line="439" class="code-line code-line code-line"><a href="https://www.cs.utah.edu/~aek/research/tree.pdf">Tree Rotations for Improving Bounding Volume Hierarchies</a></p>
    <p data-line="441" class="code-line code-line code-line"><a href="http://www.cs.utah.edu/~thiago/papers/rotations.pdf">Fast, Effective BVH Updates for Animated Scenes</a></p>
    <p data-line="443" class="code-line code-line code-line"><a href="https://dl.acm.org/citation.cfm?id=2902855">Incremental BVH construction for ray tracing</a></p>
    <div align="center">
        <img src="insertion.png" width=512>
    </div>
    <p data-line="449" class="code-line code-line code-line">構築方法ですが、説明のつながりからここで紹介します。</p>
    <p data-line="451" class="code-line code-line code-line"><a href="http://dcgi.felk.cvut.cz/publications/2013/bittner-cgf-fiobvh">Fast Insertion-Based Optimization of Bounding Volume Hierarchies</a></p>
    <p data-line="453" class="code-line code-line code-line">Reinsertionを導入した最初の論文です。個人的にはRestructuringよりも可能性を感じる方法です。Reinsertionは現状SAHを最も小さくすることができる手法として知られていますが、最適化にかかる時間がボトルネックでした。この論文が発表された時点では処理がシーケンシャルであったためです。一つずつノードを取り除き、コストを最も小さくする場所に移す必要がありますが、そういった場所が見つからないことも多く、その場合は処理が無駄になってしまいます。</p>
    <p data-line="455" class="code-line code-line code-line"><a href="https://dcgi.felk.cvut.cz/projects/prbvh/prbvh_eg.pdf">Parallel Reinsertion for Bounding Volume Hierarchy Optimization</a></p>
    <div align="center">
        <img src="teaser.svg" width=512>
    </div>
    <p data-line="461" class="code-line code-line code-line">並列化することでReinsertionによる最適化を改善する方法です。 直感に反しますが、実は並列化していないものよりもSAHを小さくすることができます。BVHのトポロジーを変化させるので、並列化する場合にスレッドが衝突しないよう操作中のノードまたはその子や親などロックする必要があります。論文ではロックの仕方が2つ提案されており、一つはConservative、もうひとつはAggressiveと呼ばれています。Conservativeでは上の図であるようなReinsertionの操作でたどるパス上にあるノードをすべてロックします。Aggressiveではノードの挿入によって実際に変更を受けるノードだけをロックし、AgressiveではSAHをより小さくすることが出来ます。考えてみれば当たり前なのですが、一つの子孫にあたるノードを取り除いただけでは大して表面積が小さくならなかったノードも、複数を同時に取り除けば表面積が非常に小さくなる場合があり、シーケンシャルの手法よりも最適化のための探索領域が広がるのです。</p>
    <h3 id="reorderingtraversal-order-3" data-line="463" class="code-line code-line code-line" id="reorderingtraversal-order-4" id="reorderingtraversal-order-5">Reordering/Traversal Order</h3>
    <p data-line="465" class="code-line code-line code-line">RestructuringとReinsertionはBVHのトポロジーを変えてしまうものですが、Traversal OrderとReorderingはBVHのトポロジーを変えずに処理速度を向上させます。これらは基本的には同じものですが、強いて違いを挙げるならば、Traversal Orderは、どのノードをどういう順で訪れるか、ランタイムでなんらかの計算を行い決定します。Reorderingは構築後一度だけ行えば、トラバース時にオーバーヘッドが発生しない、というのがメリットです。</p>
    <p data-line="467" class="code-line code-line code-line">通常レイ・トレーシングでは一番近いオブジェクトを見つけることが目的であり、Closest-Hitと呼ばれるテストを行います。しかし、影の計算や遮蔽の計算、コリジョン・ディテクションでは何かに当たるということさえ分かれば処理を完了することができるので、交差判定・当たり判定の処理は簡略化することができます。こういったテストはAny-Hitと呼ばれ、子ノードのReorderingによる高速化が可能です。</p>
    <p data-line="469" class="code-line code-line code-line"><a href="http://gamma.cs.unc.edu/SATO/SATO_files/sato_preprint.pdf">SATO: Surface Area Traversal Order for Shadow Ray Tracing</a></p>
    <p data-line="471" class="code-line code-line code-line">これはツリーの最適化ではなくトラバースの最適化に関するものです。表面積の大きいノードが影を作ることが多いであろうという前提をもとに、トラバーサルの順番を決めます。もちろんシーン中のライトの位置などが考慮されていないため、常に効果があるわけではなく、状況によっては遅くなることがあります。</p>
    <p data-line="473" class="code-line code-line code-line"><a href="http://graphics.cs.cmu.edu/projects/srdh/feltman12_srdh.pdf">SRDH: Specializing BVH Construction and Traversal Order Using Representative Shadow Ray Sets</a></p>
    <div align="center">
        <img src="srdh.png" width=512>
    </div>
    <p data-line="478" class="code-line code-line code-line">より良い方法は、この論文のようにRepresentative Rayを投げシーンに応じた最適化を行う方法です。</p>
    <p data-line="480" class="code-line code-line code-line"><a href="http://jcgt.org/published/0005/02/02/">An N-ary BVH Child Node Sorting Technique for Occlusion Tests</a></p>
    <p data-line="482" class="code-line code-line code-line">SRDHはBinary BVHにのみにしか利用できず、Shadow Ray専用のBVHと通常のBVHを保持するのでメモリを余計に消費します。私が考えた方法では、トラバーサルのコスト関数をWide BVHへと一般化し、最適化をノードの並べ替えのみと限定することで、メモリの消費を抑えます。もう少し分かりやすいタイトルにすべきであったと反省しています。</p>
    <h3 id="re-braiding-3" data-line="484" class="code-line code-line code-line" id="re-braiding-4" id="re-braiding-5">Re-braiding</h3>
    <p data-line="486" class="code-line code-line code-line">
        <a href="https://embree.github.io/papers/2017-HPG-openmerge.pdf">
            Improved Two-Level BVHs using Partial Re-Braiding
        </a>
    </p>
    <div align="center">
        <img src="rebraiding.png" width=320>
    </div>
    <p data-line="492" class="code-line code-line code-line">構築時間を短縮したり、アニメーションを簡単にサポートするためにTwo-Level BVHとよばれる2階層のBVHが使われます。これは、同じオブジェクトに所属するプリミティブ、あるいは何かしらの意味を持つプリミティブの集合ごとにBVHを構築し、それらのルートをリーフとみなして、さらに上位の階層のBVHを構築する方法です。</p>
    <p data-line="494" class="code-line code-line code-line">一部のオブジェクトが動く場合などを効率よく扱うことが出来ますが、オブジェクト同士、インスタンス同士がオーバーラップした場合はレイ・トレーシングのパフォーマンスが著しく低下するのは想像に難くないでしょう。</p>
    <p data-line="496" class="code-line code-line code-line">この論文ではRe-braidingと呼ばれるテクニックを用いて、わずかな追加のメモリと構築時間でオブジェクトが重なった場合のパフォーマンスの低下を防ぎます。基本的にはBonsaiで提案された刈込と同様の処理を行います。</p>
<pre data-line="498" class="code-line code-line code-line"><code>struct Bref
{
    BVNodeReference ref;
    AABB bounds;
    unsigned int objectID;
    unsigned int numPrims;
};
</code></pre>
    <p data-line="506" class="code-line code-line code-line">Re-braidingではBRefと呼ばれるオブジェクトごとのBVHを参照するデータ構造を使用します。まず、各オブジェクトを参照するBRefを用意します。次に、各Brefが参照しているノードのバウンディング・ボックスがある閾値より大きい場合は、そのBRefを削除し、参照していたノードを刈り込んで、その子ノードを参照するBrefを2つ(Binary BVHの場合は２つ、Wide BVHであれば４や８となります)新たに追加します。この処理BRefが事前に決めた数に達するまで、あるいは刈り込むノードがなくなるまで続けます。最後に、出来上がったBRefをリーフとしてBinningを使い上位レベルのBVHを構築します。</p>
    <p data-line="508" class="code-line code-line code-line">オブジェクトごとのBVHはBinningやSweepで高品質なものを作り、それらには手を加えないところがポイントです。またBRefには、参照しているサブツリーに含まれるプリミティブの数をストアしておきます。そうすることで、上位のBVHを作る際、適切にサブツリーのコストを考慮に入れることが出来ます。複数種類のインスタンスがある場合、それぞれの交差判定にかかるコストは当然違いますから、それらをリーフとして扱う場合には注意が必要です。</p>
<pre data-line="510" class="code-line code-line code-line"><code>インスタンスはプロダクションのレンダラでは必須の機能ですが、それを扱った論文はそれほど多くありません。Sony Pictures ImageworksのArnoldではシングル・レベルのインスタンシングのみをサポートしています(2018年の執筆時点)。当然マルチレベル・インスタンシングのほうが汎用性が高く、より省メモリで複雑なモデルを扱えますが、セルフ・ヒットを避けるコードや、インスタンスごとに色を変えるシェーダではひと工夫必要になります。
</code></pre>
    <h3 id="quantizationcompression-3" data-line="512" class="code-line code-line code-line" id="quantizationcompression-4" id="quantizationcompression-5">Quantization/Compression</h3>
    <p data-line="514" class="code-line code-line code-line">BVH自体がレンダリングされるジオメトリに次いで、非常に多くのメモリを消費します。したがって、BVHのノードを圧縮する方法が多数提案されています。</p>
    <p data-line="516" class="code-line code-line code-line"><a href="https://pdfs.semanticscholar.org/c329/a3456cb8ed426472d281bea42320a37a711a.pdf">Memory Efficient Ray Tracing with Hierarchical Mesh Quantization</a> <a href="https://patents.google.com/patent/US20110080403A1/en">(US20110080403A1)</a></p>
    <div align="center">
        <img src="quantization.png" width=512>
    </div>
    <p data-line="521" class="code-line code-line code-line">データをQuantize(量子化)するものが一番わかりやすいでしょうか。さらにこの手法ではBVHの中にジオメトリデータをストアします。バウンディング・ボックスの頂点座標を親ノードのバウンディング・ボックスでの相対的な座標で表し、量子化することでメモリを節約します。</p>
    <p data-line="523" class="code-line code-line code-line">さらに、ポリゴンの頂点データなども同様に相対的な座標で表し量子化することで、データ量を大きく削減できます。形が変わってしまうと思うかもしれませんが、BVHが階層的な構造であることを思い出してください。リーフを含むノードは一般的にかなり小さいので、量子化してもそれほど目立つアーティファクトが生じません。</p>
    <p data-line="525" class="code-line code-line code-line"><a href="https://embree.github.io/data/compressedleafbvh-hpg-2018-final.pdf">Compressed-Leaf Bounding Volume Hierarchies</a></p>
    <p data-line="527" class="code-line code-line code-line">レイ・トレーシングにおいてはレイとノードとの交差判定が大部分を占め、リーフ・ノードとの交差判定はそこまで多くない、という洞察をもとに、リーフノードのみを圧縮します。</p>
    <h3 id="e38288e3828ae889afe38184e383ace382a4e382a2e382a6e38388-3" data-line="529" class="code-line code-line code-line" id="e38288e3828ae889afe38184e383ace382a4e382a2e382a6e38388-4" id="e38288e3828ae889afe38184e383ace382a4e382a2e382a6e38388-5">より良いレイアウト</h3>
    <p data-line="531" class="code-line code-line code-line">キャッシュ・ミスを減らしたり、消費メモリを減らす様々なレイアウトが提案されています。あまり触れている論文がありませんが、巡回セールスマン問題を用いてレイアウト最適化を行うこともできます。</p>
    <p data-line="533" class="code-line code-line code-line"><a href="http://gamma.cs.unc.edu/COLBVH/">Cache-Efficient Layouts of Bounding Volume Hierarchies</a></p>
    <p data-line="535" class="code-line code-line code-line">キャッシュ・ミスを減らすようにノードのレイアウトを変える最適化手法です。</p>
    <p data-line="537" class="code-line code-line code-line"><a href="https://graphics.tu-bs.de/publications/Eisemann11NMH">Implicit Object Space Partitioning: The No-Memory BVH</a></p>
    <p data-line="539" class="code-line code-line code-line">＊＊＊BVHのノードで最もメモリを消費するのはバウンディング・ボックスの座標です。XYZそれぞれ最大値と最小値を保持した場合、単精度でも24バイト消費します。</p>
    <h3 id="e3838fe383bce38389e382a6e382a7e382a2-3" data-line="541" class="code-line code-line code-line" id="e3838fe383bce38389e382a6e382a7e382a2-4" id="e3838fe383bce38389e382a6e382a7e382a2-5">ハードウェア</h3>
    <p data-line="543" class="code-line code-line code-line">これは理論的な部分ではないので、いくつか論文を紹介するにとどめます。</p>
    <p data-line="545" class="code-line code-line code-line"><a href="https://dl.acm.org/citation.cfm?id=3128466">Fast Hardware Construction and Refitting of Quantized Bounding Volume Hierarchies</a></p>
    <p data-line="547" class="code-line code-line code-line"><a href="http://www.tut.fi/vga/publications/PLOCTree_A_Fast_High-Quality_Hardware_BVH_Builder.html">PLOCTREE: A FAST, HIGH-QUALITY HARDWARE BVH BUILDER</a></p>
    <p data-line="549" class="code-line code-line code-line">PLOCのハードウェア実装です。</p>
    <p data-line="551" class="code-line code-line code-line"><a href="https://tutcris.tut.fi/portal/files/13191965/paper.pdf">MergeTree: A Fast Hardware HLBVH Constructor for Animated Ray Tracing</a></p>
    <p data-line="553" class="code-line code-line code-line">HLBVHのハードウェア実装で、加えてルート・ノードに近いノードのみSAHを小さくするよう、最適化します。ルートに近い部分だけを最適化するのは、表面積が大きいため、パフォーマンスへのインパクトが大きいからです。</p>
    <p data-line="555" class="code-line code-line code-line">
        <a href="https://tutcris.tut.fi/portal/files/11500579/egsr_preprint.pdf">
            Fast Hardware Construction and Refitting of Quantized Bounding
            Volume Hierarchies
        </a>
    </p>
    <p data-line="558" class="code-line code-line code-line"><a href="http://www.cemyuksel.com/research/papers/dual_streaming_hpg2017.pdf">Dual Streaming for Hardware-Accelerated Ray Tracing</a></p>
    <h2 id="e8a3bde59381e9968be799bae383bbe38397e383ade38380e382afe382b7e383a7e383b3e789b9e69c89e381aee8a9b1e9a18c-3" data-line="560" class="code-line code-line code-line" id="e8a3bde59381e9968be799bae383bbe38397e383ade38380e382afe382b7e383a7e383b3e789b9e69c89e381aee8a9b1e9a18c-4" id="e8a3bde59381e9968be799bae383bbe38397e383ade38380e382afe382b7e383a7e383b3e789b9e69c89e381aee8a9b1e9a18c-5">製品開発・プロダクション特有の話題</h2>
    <h3 id="e383a2e383bce382b7e383a7e383b3e383bbe38396e383a9e383bc-3" data-line="562" class="code-line code-line code-line" id="e383a2e383bce382b7e383a7e383b3e383bbe38396e383a9e383bc-4" id="e383a2e383bce382b7e383a7e383b3e383bbe38396e383a9e383bc-5">モーション・ブラー</h3>
    <p data-line="564" class="code-line code-line code-line">BVHがレイ・トレーシングのデータ構造として主流になったのには理由があります。考え方自体が非常に単純でありkd-treeよりロバストであること、またプロダクション・レンダラで必須のモーション・ブラーの実装がしやすい、などが挙げられるでしょうか。</p>
    <p data-line="566" class="code-line code-line code-line">過去RotaionやRefittingの組み合わせでアニメーションに対応する方法が提案されてきました。しかし、これらの手法は多数のCPUコアでスケールさせるのが意外に難しく、プロダクションレンダラではモーションブラーが適応されたオブジェクト専用のBVHを構築することが多いです。</p>
    <p data-line="568" class="code-line code-line code-line">個人的にはこれらのBVHはメモリの消費が２倍近く、あるいはそれ以上になってしまうのであまり好きではありません。</p>
    <p data-line="570" class="code-line code-line code-line"><a href="https://fpsunflower.github.io/ckulla/data/2018_tog_spi_arnold.pdf">Sony Pictures Imageworks Arnold</a></p>
    <p data-line="572" class="code-line code-line code-line">モーションブラー用のBVHはこちらの文献にあるように、各ノードがモーションパスの両端に相当する２つのバウンディング・ボックスを持っています。交差判定中はそれらが適宜線形補間されます。</p>
    <p data-line="574" class="code-line code-line code-line"><a href="https://www.solidangle.com/research/Arnold_TOG2018.pdf">Arnold: A Brute-Force Production Path Tracer</a></p>
    <p data-line="576" class="code-line code-line code-line">当然といえば当然ですが、Solid AngleのArnoldも同じアプローチです。</p>
    <p data-line="578" class="code-line code-line code-line"><a href="http://gruenschloss.org/msbvh/msbvh.pdf">MSBVH: An Efﬁcient Acceleration Data Structure for Ray Traced Motion Blur</a></p>
    <div align="center">
        <img src="msbvh.png" width=512>
    </div>
    <p data-line="584" class="code-line code-line code-line">Spatial Splitsを使って構築した場合はプリミティブ(厳密にはその参照)が複製され、複数の別のノードから同じプリミティブが参照されます。プリミティブが１つのノードのバウンディング・ボックスだけに収まらず、複数にまたがるためです。言い換えれば、一つのプリミティブへの参照が複製されます。静的なシーンであればこの扱いはそれほど難しくはないのですが、モーション・ブラーがかかわってくると厄介です。</p>
    <p data-line="586" class="code-line code-line code-line">この論文ではSplitsを使いながらもノードの重なりを減らす方法を提案しています。</p>
    <p data-line="588" class="code-line code-line code-line">はじめに、時間を(t=0.5, (0&lt;=t&lt;=1))で固定してSBVHを構築し、BVHのトポロジーを決定します。ポリゴンはSplit(切断)されるため、バウンディング・ボックスとポリゴンの交点を求める必要がありますが、それらを重心座標系で保持しておくと、モーション・セグメントの両端点((t=0.0)と(t=1.0))での座標も容易に求めることができます。両端でのバウンディング・ボックスは両端での交点を全て含むようフィットさせます。この両端でのバウンディング・ボックスはクリッピング・ボックスと呼ばれます。<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>t</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;t&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></eq>では２つのクリッピング・ボックスを補間し、それを用いて交差判定を行います。</p>
    <p data-line="590" class="code-line code-line code-line">バウンディング・ボックスの重なりが完全になくなるのではありませんが、Spatial Splitsを使用したBVHでもモーション・ブラーを効率よく扱えるようになります。</p>
    <div align="center">
        <img src="degenerated.png" width=320>
    </div>
<pre data-line="596" class="code-line code-line code-line"><code>この手法には考えられる欠点が２つあります。一つ目は、図のようにt=0.5の時にポリゴンが縮退する場合、Clippingがロバストにできないであろうということ。二つ目は、前述のように0&lt;t&lt;1ではクリッピング・ボックスを補間しますが、t=0.5付近では補間されたバウンディング・ボックスがタイトにフィットしないということです。実際あまり起きないのでは、と思うかもしれませんが、モーション・グラフィックスなどでの使用も考えると、不安要素は取り除いておきたいものです。
</code></pre>
    <p data-line="598" class="code-line code-line code-line"><a href="https://embree.github.io/papers/2017-HPG-msmblur.pdf">STBVH: A Spatial-Temporal BVH for Efficient Multi-Segment Motion Blur</a> <a href="https://patents.google.com/patent/US9430863">(US9430863B1)</a></p>
    <p data-line="600" class="code-line code-line code-line">コスト関数のところで出てきましたが、こちらもモーション・ブラー用のBVHについての論文ですが、モーション・セグメントが１つではなく、複数の場合へと拡張しています。構築の際には、プリミティブを時間軸でグループ分けするか、オブジェクト単位でグループ分けするか、交差判定の負荷が小さくなるように決定します。</p>
    <h3 id="e8aaa4e5b7ae-3" data-line="602" class="code-line code-line code-line" id="e8aaa4e5b7ae-4" id="e8aaa4e5b7ae-5">誤差</h3>
    <p data-line="604" class="code-line code-line code-line">交差判定の誤差は厄介な問題です。BVHはkd-treeに比べロバストですが、それでも問題が生じます。</p>
    <p data-line="606" class="code-line code-line code-line"><a href="http://jcgt.org/published/0002/02/02/">Robust BVH Ray Traversal</a></p>
    <h2 id="e8aab2e9a18c-3" data-line="608" class="code-line code-line code-line" id="e8aab2e9a18c-4" id="e8aab2e9a18c-5">課題</h2>
    <p data-line="610" class="code-line code-line code-line">非常に多くの研究が行われてきていますが、まだまだ答えのはっきりしない問題がたくさんあります。研究テーマとして挙げておきます。</p>
    <h3 id="e8a487e695b0e7a8aee9a19ee381aee38397e383aae3839fe38386e382a3e38396-3" data-line="612" class="code-line code-line code-line" id="e8a487e695b0e7a8aee9a19ee381aee38397e383aae3839fe38386e382a3e38396-4" id="e8a487e695b0e7a8aee9a19ee381aee38397e383aae3839fe38386e382a3e38396-5">複数種類のプリミティブ</h3>
    <p data-line="614" class="code-line code-line code-line">いろいろな種類のプリミティブ、カーブやポリゴン、パーティクルなどをどう扱うかというのはなかなか難しい問題です。それぞれのプリミティブのみを扱う別々のBVHを構築するのがよいか、すべてのオブジェクトを一緒に扱って一つのBVHを作るか選択肢は2つありますが、それぞれに長所短所があります。</p>
    <p data-line="616" class="code-line code-line code-line"><a href="https://projet.liris.cnrs.fr/m2disco/pub/Congres/2014-HPG/2%20Ray%20Tracing/2%20Exploiting%20Local%20Orientation%20Similarity%20for%20Efficient%20Ray%20Traversal%20of%20Hair%20and%20Fur.pdf">Exploiting Local Orientation Similarity for Efficient Ray Traversal of Hair and Fur</a></p>
    <p data-line="618" class="code-line code-line code-line">この論文では、毛をうまく扱うために、毛の向きに沿うようバウンディングボックスをトランスフォームするという方法が提案されています。しかし、行列をストアするので追加で必要となるメモリが問題となってきます。また、過度にカールした髪の毛の扱いも厄介です。</p>
    <h3 id="e79baee79a84e588a5e381aebvh-3" data-line="620" class="code-line code-line code-line" id="e79baee79a84e588a5e381aebvh-4" id="e79baee79a84e588a5e381aebvh-5">目的別のBVH</h3>
    <p data-line="622" class="code-line code-line code-line">現状、一般的には目的別(交差判定、衝突判定、照明計算)のBVHが用意されます。用途の数を<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span></eq>、プリミティブの種類を<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></eq>、さらに静的・動的の組み合わせを考えると<eq><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>O</mi><mo>×</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">2 \times O \times P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></eq>のBVHを管理しなければならず、非常に厄介です。どのようにすれば万能なBVHをつくることができるでしょうか？個人的にはこの研究をしたいと思います。最近ではLight Transportでも使われる用ですし、複雑さは増していく一方です。</p>
    <h3 id="wide-bvhe381aee69c80e981a9e58c96-3" data-line="624" class="code-line code-line code-line" id="wide-bvhe381aee69c80e981a9e58c96-4" id="wide-bvhe381aee69c80e981a9e58c96-5">Wide BVHの最適化</h3>
    <p data-line="626" class="code-line code-line code-line">ここで取り上げた最適化手法はReorderingを除いてWide BVHにそのまま使えないもの、あるいは組み合わせの爆発で使用が現実的でないものばかりです。また最適化はEPOや、シーン内におけるレイの分布を考慮に入れて行うべきですが、それらを見積もるにもコスト(時間とメモリ)がかかるので、SAHを減らすように最適化を行うものが主流となっています。</p>
    <h3 id="e4bb96e58886e9878ee381a7e381aee588a9e794a8-3" data-line="628" class="code-line code-line code-line" id="e4bb96e58886e9878ee381a7e381aee588a9e794a8-4" id="e4bb96e58886e9878ee381a7e381aee588a9e794a8-5">他分野での利用</h3>
    <p data-line="630" class="code-line code-line code-line">レンダリングでは3次元のBVHが主に使われますが、初めに書いたように次元を上げたり下げたりすれば、全く別の分野で記事で取り上げた最適化のテクニックが使えると思います。</p>
    <h2 id="e38195e38184e38194e381ab-3" data-line="632" class="code-line code-line code-line" id="e38195e38184e38194e381ab-4" id="e38195e38184e38194e381ab-5">さいごに</h2>
    <p data-line="634" class="code-line code-line code-line">さまざまな手法を紹介しましたが、いかがだったでしょうか？論文の翻訳ではなく、多分に私の主観が入ったコメントが多くなったかと思いますが、長年やってきて正しいと思うことを述べるように努めました。</p>
    <p data-line="636" class="code-line code-line code-line">紹介した以外にもまだまだ論文がありますし、知っていることを全て書いたわけでもありませんが(また、書けないこともあります)、この記事が何かしら研究や開発の参考、あるいはデータ構造に興味を持ってもらえるきっかけとなれば幸いです。</p>
    <p data-line="638" class="code-line code-line code-line">また、BVHよりもさらに優れたデータ構造が存在することも十分考えられますので、固定観念にとらわれず、いろいろなアイデアを自由に試してみてください。</p>
    <p data-line="640" class="code-line code-line code-line">この記事ではレンダリングに重きを置きましたが、衝突判定は勉強してまたいつか別の記事で取り上げたいと思います。</p>
    <p data-line="642" class="code-line code-line code-line">一緒に研究したいという方は一報ください。お待ちしています。</p>
    <p data-line="644" class="code-line code-line code-line">
        <a href="http://dcgi.fel.cvut.cz/home/bittner/publications/Hendrich2017.pdf">Parallel BVH Construction using Progressive Hierarchical Refinement</a>
        <a href="http://drz.disneyresearch.com/~jnovak/publications/RBVH/RBVH.pdf">Rasterized Bounding Volume Hierarchies</a>
    </p>
</body>
</html>